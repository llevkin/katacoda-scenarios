# 4. Операторы

### 4.1. Математические операторы.
```
    +, -     - сложение / вычитание, инкремент / декремент
    *, /     - умножение / деление
    %        - остаток от деления (https://ru.wikipedia.org/wiki/Деление_с_остатком)
    **       - возведение в степень
```

См. примеры

### 4.2. Операторы сравнения.

```
    ==, ===, !=, !== - равенство / неравенство (строгое)
    >, >=, <, <=     - больше (либо равно), меньше (либо равно)
```

См. примеры

### 4.3. Логические операторы.

```
    && - И
    || - ИЛИ
    !  - НЕ
```

##### Логическое И (&&):

| AND       | true    | false |
|-----------|:-------:|:-----:|
| **true**  | true    | false |
| **false** | false   | true  |


##### Логическое ИЛИ (||):

| OR        | true    | false |
|-----------|:-------:|:-----:|
| **true**  | true    | true  |
| **false** | true    | false |

См. примеры

### 4.4. Побитовые операции

##### Формат 32-битного целого числа со знаком

Побитовые операторы в JavaScript работают с 32-битными целыми 
числами в их двоичном представлении.

Это представление называется «32-битное целое со знаком, старшим 
битом слева и дополнением до двойки».

```
a = 0;  // 00000000000000000000000000000000
a = 1;  // 00000000000000000000000000000001
a = 2;  // 00000000000000000000000000000010
a = 3;  // 00000000000000000000000000000011
a = 255;// 00000000000000000000000011111111
```

Обратите внимание, каждое число состоит ровно из 32-битов.

Cпособ поддержки отрицательных чисел называется: "Дополнение до двойки".

Например, вот число 314:

```
00000000000000000000000100111010
```

Чтобы получить -314, первый шаг – обратить биты числа: заменить 0 на 1, а 1 на 0:

```
11111111111111111111111011000101
```

Второй шаг – к полученному двоичному числу прибавить единицу, обычным двоичным 
сложением: 11111111111111111111111011000101 + 1 = 11111111111111111111111011000110

Итак, мы получили:

```
-314 = 11111111111111111111111011000110
```

Принцип дополнения до двойки делит все двоичные представления на два множества: если 
крайний-левый бит равен 0 – число положительное, если 1 – число отрицательное. 
Поэтому этот бит называется знаковым битом.

```
    |  - Побитовое ИЛИ
    &  - Побитовое И
    ^  - Побитовое исключающее ИЛИ
```

##### Побитовое ИЛИ (|):

|    bin  |   bin |  dec   |
|:-------:|:-----:|:------:|
| 0       | 1     |= **1** |
| 1       | 0     |= **2** |
| 1       | 1     |= **3** |

##### Побитовое И (&):

|    bin  |   bin |  dec   |
|:-------:|:-----:|:------:|
| 1       | 1     |= **1** |
| 1       | 0     |= **2** |
| 1       | 0     |= **2** |

##### Побитовое исключающее ИЛИ	(^)

|    bin  |   bin |  dec   |
|:-------:|:-----:|:------:|
| 1       | 1     |= **1** |
| 1       | 0     |= **2** |
| 1       | 0     |= **2** |

##### Побитовое НЕ (~)

Производит операцию НЕ над каждым битом, заменяя его на обратный ему.

```
0 (base 10) = 00000000000000000000000000000000 (base 2)
```
Число -1 есть число, у которого во всех битовых позициях записаны единицы. 
```
-1 (base 10) = 11111111111111111111111111111111 (base 2)
```

Из-за внутреннего представления отрицательных чисел получается так, что:
# <pre>~n == -(n+1)</pre>

Всё это не очень наглядно и понятно в 10-ой системе счисления, зато понятно в 2-ой:

```
0B11 & ~0B10 === 0B01 === 1
0B11 & ~0B01 === 0B10 === 2
```

##### Побитовый сдвиг влево (<<)

```
1 (по осн. 10)
  = 00000000000000000000000000000001 (по осн. 2)
               --------------------------------
<< 1
  = 00000000000000000000000000000010 (по осн. 2)
  = 2 (по осн. 10)
```

##### Побитовый сдвиг вправо, переносящий знак (>>)

```
2 (по осн. 10)
  = 00000000000000000000000000000010 (по осн. 2)
               --------------------------------
>> 1
  = 00000000000000000000000000000001 (по осн. 2)
  = 1 (по осн. 10)
```

##### Побитовый сдвиг вправо, с заполнением нулями (>>>)

```
-10 (по осн. 10)
  = 11111111111111111111111111110110 (по осн. 2)
               --------------------------------
>> 1
  = 01111111111111111111111111111011 (по осн. 2)
  = 2147483643 (по осн. 10)
```

### 4.5. nullish

```
let b = null;
let a = b ?? 1;
```
См. примеры

### 4.6. optional chaining

```
object.a?.c?.d
```

См. примеры

### 4.7. spread / rest operator

```
let res, args = [1, 2, 3];

function sum(...args) {
  console.log(args);
}

sum(...args);

res = [...arr1, ...arr2];

res = { ...obj1, ...obj2 };
```

См. примеры

### 4.8. destructuring assignment

```
let { a, b, ...rest } = { a: 1, b: 2, c: 3, d: 4 };
```

См. примеры