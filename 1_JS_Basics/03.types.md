# 3. Типы данных

JavaScript определяет 7 типов данных:

![JS Types](https://github.com/llevkin/katacoda-scenarios/blob/master/1_JS_Basics/img/js_types.jpg?raw=true)

Все типы данных кроме объектов — примитивные. 

Оператор typeof возвращает тип данных для значения в виде строки. 

```js
let a = 1;
typeof a; // number
```

В JavaScript 6 примитивных типов: **string**, **number**, **boolean**, **symbol**, **null**, **undefined**.
JavaScript позволяет нам работать с примитивными типами данных, как будто они являются объектами 
(вызывать методы, свойства). Несмотря на это примитивы – не объекты. 

**Почему?**

- операции с примитивами выполняются гораздо быстрее чем операции с объектами
- примитивы "легче" объектов (экономия памяти)
- примитивы легче вычищать сборщиком мусора

Итак - примитивы остаются примитивами, однако язык позволяет 
осуществлять доступ к их методам и свойствам, как?
 
Cоздаётся специальный «объект-обёртка», который предоставляет нужную функциональность.
По спецификации - должен создаваться специальный объект в момент обращения к методу
примитива, выполняться, после чего объект - удаляется. Движок JavaScript сильно оптимизирует 
этот процесс.

Каждый примитив имеет свой собственный «объект-обёртку», которые называются: 
String, Number, Boolean и Symbol. Таким образом, они имеют разный набор методов.

Некоторые языки, такие как Java, позволяют явное создание «объектов-обёрток» для 
примитивов при помощи такого синтаксиса как new Number(1) или new Boolean(false).

В JavaScript, это тоже возможно по историческим причинам, но очень не рекомендуется. 
В некоторых местах последствия могут быть катастрофическими.

См. пример.

### 3.1. Boolean

См. пример.

### 3.2. String

В JavaScript любые текстовые данные являются строками.
Внутренний формат для строк — всегда UTF-16, вне зависимости от кодировки страницы.

##### Кавычки

В JavaScript есть разные типы кавычек.
Строку можно создать с помощью одинарных, двойных либо обратных кавычек.
Одинарные и двойные кавычки работают, по сути, одинаково и экранируют друг-друга.
При использовании обратных кавычек в такую строку мы сможем вставлять произвольные 
выражения, обернув их в ${…}

См. пример.

### 3.3. Number

 - Внутри JavaScript число представлено в виде 64-битного формата IEEE-754, 
   который также называют «числа с плавающей точкой двойной точности» 
   (double precision floating point numbers)
 
 - Диапазон значений от <code>-2^53</code> до <code>2^53</code> 
 
##### Неточные вычисления:

- Для хранения числа используется 64 бита: 52 из них используется для хранения цифр,
  11 из них для хранения положения десятичной точки (если число целое, то хранится 0),
  и один бит отведён на хранение знака.

- Если число слишком большое, оно переполнит 64-битное хранилище, JavaScript вернёт бесконечность

 ##### 3.3.1 - 3.3.4 hex, octal, binary, exp
 
 См. пример.
 
 ##### 3.3.5 bigint
 
 BigInt не является типом Number, это встроенный объект, который предоставляет способ представлять 
 целые числа больше 253 - 1, наибольшего числа, которое JavaScript может надежно представить с Number 
 примитивом. Это максимальное значение можно получить, обратившись к Number.MAX_SAFE_INTEGER.
 Тем не менее он включен в эту главу, потому что имеет схожий (упрощённый) способ определения с Number в 
 коде.
 
 См. пример.

 ##### 3.3.6 NaN
 
 - Метод Number.isNaN() определяет, является ли переданное значение NaN. 
   Это более надёжная версия оригинальной глобальной функции isNaN().
 
 - Поскольку оба оператора проверки на равенство, == и ===, вычисляются в false при 
   проверке, что NaN и есть NaN, появляется необходимость в функции Number.isNaN(). 
   Эта ситуация отличается от всех других возможных сравнений в JavaScript.

 - В отличие от глобальной функции isNaN(), Number.isNaN() не имеет проблемы 
   принудительного преобразования параметра в число. Это значит, что в него 
   безопасно передавать значения, которые обычно превращаются в NaN, но на самом 
   деле NaN не являются. Также это значит, что метод возвращает true только для 
   числовых значений, имеющих значение NaN.
 
    ```
    Number.isNaN(NaN); // true
    Number.isNaN(Number.NaN); // true
    Number.isNaN(0 / 0) // true

    // При использовании глобальной функции isNaN() это всё будет true
    Number.isNaN('NaN');      // false
    Number.isNaN(undefined);  // false
    Number.isNaN({});         // false
    Number.isNaN('blabla');   // false

    // А это всё в любом случае будет false
    Number.isNaN(true);
    Number.isNaN(null);
    Number.isNaN(37);
    Number.isNaN('37');
    Number.isNaN('37.37');
    Number.isNaN('');
    Number.isNaN(' ');
    ```
  См. пример.
  
 ##### 3.3.7 Infinity
    
```
console.log(1e500); // Infinity
```
 См. пример.

### 3.4. undefined

- undefined является свойством глобального объекта, то есть, это переменная в 
  глобальной области видимости. Начальным значением undefined является примитивное 
  значение undefined.
  
- undefined имеет смысл «значение не присвоено».

- В современных браузерах (Firefox 4+), undefined является 
  ненастраиваемым и незаписываемым свойством, в соответствии со спецификацией ECMAScript 5. 
  Даже когда это не так, избегайте его переопределения.

- Переменная, не имеющая присвоенного значения, обладает типом undefined. Также undefined 
  возвращают метод или инструкция, если переменная, участвующая в вычислениях, не имеет 
  присвоенного значения. Функция возвращает undefined, если она не возвращает какого-либо значения.

- Поскольку undefined не является зарезервированным словом, он может использоваться в 
  качестве идентификатора (имени переменной) в любой области видимости, за исключением глобальной.
  
- В явном виде undefined обычно не присваивают, так как это противоречит его смыслу. 
  Для записи в переменную «пустого» или «неизвестного» значения используется null.
      
### 3.5. null

- Значение null является литералом JavaScript, представляющим нулевое или «пустое» 
  значение, то есть, когда нет никакого объектного значения. Это одно из примитивных 
  значений JavaScript.
  
- Значение null является литералом (а не свойством глобального объекта, как undefined). 
  В API null часто присутствует в местах, где ожидается объект, но подходящего объекта нет. 
  При проверке на null или undefined помните о различии между операторами равенства (==) 
  и идентичности (===) (с первым выполняется преобразование типов).
 
- В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», 
  как в некоторых других языках. Это просто специальное значение, которое имеет смысл 
  «ничего» или «значение неизвестно».
  
  ##### Отличия между null и undefined:
  ```js
    typeof null        // object (баг в ECMAScript, должно быть null, сохраняется для совместимости)
    typeof undefined   // undefined
    null === undefined // false
    null  == undefined // true
  ```
  
### 3.6. Symbol
    
- Символ (symbol) – примитивный тип данных, использующийся для создания 
  уникальных идентификаторов.

- Символы создаются вызовом функции Symbol(), в которую можно передать 
  описание (имя) символа.

- Даже если символы имеют одно и то же имя, это – разные символы. 
  Если мы хотим, чтобы одноимённые символы были равны, то следует 
  использовать глобальный реестр: вызов Symbol.for(key) возвращает 
  (или создаёт) глобальный символ с key в качестве имени. Многократные 
  вызовы команды Symbol.for с одним и тем же аргументом возвращают один 
  и тот же символ.

- Символы имеют два основных варианта использования:

    - «Скрытые» свойства объектов. Если мы хотим добавить свойство в объект, 
      который «принадлежит» другому скрипту или библиотеке, мы можем создать 
      символ и использовать его в качестве ключа. Символьное свойство не 
      появится в for..in, так что оно не будет нечаянно обработано вместе с другими. 
      Также оно не будет модифицировано прямым обращением, так как другой скрипт не 
      знает о нашем символе. Таким образом, свойство будет защищено от случайной 
      перезаписи или использования.

    - Так что, используя символьные свойства, мы можем спрятать что-то нужное нам, 
      но что другие видеть не должны.

- Существует множество системных символов, используемых внутри JavaScript, 
  доступных как Symbol.*. Мы можем использовать их, чтобы изменять встроенное 
  поведение ряда объектов. Например, использовать Symbol.iterator для итераторов, 
  Symbol.toPrimitive для настройки преобразования объектов в примитивы и так далее.

- Технически символы скрыты не на 100%. Существует встроенный 
  метод Object.getOwnPropertySymbols(obj) – с его помощью можно
  получить все свойства объекта с ключами-символами. Также существует 
  метод Reflect.ownKeys(obj), который возвращает все ключи объекта, 
  включая символьные. Так что они не совсем спрятаны. Но большинство 
  библиотек, встроенных методов и синтаксических конструкций не 
  используют эти методы.

См. пример.
  
### 3.7. Object

Все объекты в JavaScript являются потомками Object; все объекты наследуют методы и свойства
из прототипа объекта Object.prototype, хотя они и могут быть переопределены. 

См. пример.

- #### 3.7.1. Array
    Массив (Array) в JavaScript является глобальным объектом, 
    который используется для создания массивов; которые представляют собой 
    высокоуровневые спископодобные объекты.

    См. пример.
   
- #### 3.7.2. Function

    См. пример.
    
- #### 3.7.3. Date

    Создаёт экземпляр объекта Date, представляющего собой момент времени.
    Объекты Date основываются на значении количества миллисекунд, 
    прошедших с 1 января 1970 года в часовом поясе UTC.
    
    См. пример.
    
- #### 3.7.4. RegExp
    ```
    /pattern/flags
    ```
    
    ##### pattern
    
    - Текст регулярного выражения.
    
    ##### flags

    - Если определён, может принимать любую комбинацию нижеследующих значений:
    
    ```
        g - глобальное сопоставление
        i - игнорирование регистра при сопоставлении
        m - сопоставление по нескольким строкам; 
            символы начала и конца (^ и $) 
            начинают работать по нескольким строкам 
            (то есть, происходит сопоставление 
            с началом или концом каждой строки 
            (строки разделяются символами \n или \r),
            а не только с началом или концом 
            всей вводимой строки)
        y - «липкий» поиск; сопоставление в целевой 
            строке начинается с индекса, 
            на который указывает свойство lastIndex 
            этого регулярного выражения 
            (и не пытается сопоставиться с 
            любого более позднего индекса).
    ```

    См. пример.
