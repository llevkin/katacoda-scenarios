# 1. Event loop

Оригинальные статьи тут: 

https://habr.com/ru/post/479062/

https://medium.com/devschacht/event-loop-timers-and-nexttick-18579cd122e0

![EL_1](https://github.com/llevkin/katacoda-scenarios/blob/master/3_NodeJS/img/Event_loop_1.png?raw=true)
![EL_2](https://github.com/llevkin/katacoda-scenarios/blob/master/2_NodeJS/img/Event_loop_2.png?raw=true)

### 1 фаза — таймеры

Данная фаза выполняется непосредственно Event Loop'ом. 
(Фрагмент кода с **uv_update_time**) — здесь просто обновляется время, 
когда начал работать Event Loop.

**uv_run_timers** — в этом методе выполняется следующее действие с 
таймером. Есть определённый стек, точнее, куча таймеров, это, 
по сути, то же самое, что очередь, где находятся таймеры. 
Берётся таймер с самым маленьким временем, сравнивается с 
текущим времени Event Loop'а, и, если настало время для 
исполнения данного таймера, выполняется его callback. 
Здесь стоит отметить что в Node.js есть реализация 
setTimeout и есть setInterval. Для libuv это, по сути, одно 
и то же, только в setInterval ещё есть флаг repeat.

### 2 фаза — I/O-callback'и

Здесь выполняются callback'и для неблокирующего 
ввода/вывода, т. е. это именно те функции, которые используются после 
запроса в базу данных или другой ресурс или на чтение/запись файла,
за исключением событий close, таймеров и setImmediate(). 

В исходном коде это строка 367: **ran_pending = uv_run_pending(loop)**.

### 3 фаза — ожидание, подготовка

Используется только для внутренних целей;

В исходном коде это строки 368, 369:
**uv_run_idle(loop)** — ожидание;
**uv_run_prepare(loop)** — подготовка.

### 4 фаза — опрос

Здесь выполняется весь наш код, который мы пишем на JS. 
Первоначально все запросы, которые мы делаем, попадают 
именно сюда, и именно здесь Node.js может быть заблокирована. 
Если сюда попадёт какая-либо тяжёлая операция по вычислению, 
то на этом этапе наше приложение может просто зависнуть и ожидать, 
пока не выполнится данная операция.

В исходном коде это строка 370: **uv_io_poll(loop, timeout)**.

### 5 фаза — проверка

В Node.js есть таймер setImmediate, его callback'и 
выполняются на этой фазе.

В исходном коде это строка 371: **uv_run_check(loop)**.

### 6 фаза (последняя) — callback'и событий close

Например, web-сокету нужно закрыть соединение, на этой фазе 
будет вызван callback этого события.

В исходном коде это строка 372: **uv_run_closing_handless(loop)**.

**Между каждой итерацией цикла событий Node.js проверяет, 
ожидается ли завершение каких-либо асинхронных операций ввода/вывода 
или таймеров, и завершает работу, если их нет.**

### setImmediate() vs setTimeout()

**setImmediate()** - предназначен для выполнения сценария после завершения текущей фазы опроса (на фазе проверки).

**setTimeout()** - планирует запуск сценария после истечения минимального порога в миллисекундах.

### process.nextTick() vs setImmediate()

**process.nextTick()** - срабатывает сразу на той же фазе

**setImmediate()** - срабатывает на следующей итерации или «тике» цикла событий