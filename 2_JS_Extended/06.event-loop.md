# 6. Event loop

Оригинальная статья тут: 
https://habr.com/ru/post/479062/

![EL_1](https://github.com/llevkin/katacoda-scenarios/blob/master/2_JS_Extended/img/Event_loop_1.png?raw=true)
![EL_2](https://github.com/llevkin/katacoda-scenarios/blob/master/2_JS_Extended/img/Event_loop_2.png?raw=true)

### 1 фаза — таймеры

Данная фаза выполняется непосредственно Event Loop'ом. 
(Фрагмент кода с **uv_update_time**) — здесь просто обновляется время, 
когда начал работать Event Loop.

**uv_run_timers** — в этом методе выполняется следующее действие с 
таймером. Есть определённый стек, точнее, куча таймеров, это, 
по сути, то же самое, что очередь, где находятся таймеры. 
Берётся таймер с самым маленьким временем, сравнивается с 
текущим времени Event Loop'а, и, если настало время для 
исполнения данного таймера, выполняется его callback. 
Здесь стоит отметить что в Node.js есть реализация 
setTimeout и есть setInterval. Для libuv это, по сути, одно 
и то же, только в setInterval ещё есть флаг repeat.

### 2 фаза — I/O-callback'и

Здесь выполняются callback'и для неблокирующего 
ввода/вывода, т. е. это именно те функции, которые используются после 
запроса в базу данных или другой ресурс или на чтение/запись файла. 
Они выполняются именно на данной фазе.

В исходном коде это строка 367: **ran_pending = uv_run_pending(loop)**.

### 3 фаза — ожидание, подготовка

Это внутренние операции для callback'ов, по сути, 
мы не можем влиять на фазу, только косвенно. 
Есть process.nextTick, его callback может ненамеренно 
быть исполнен на фазе «ожидание, подготовка». 
process.nextTick выполняется на текущей фазе, 
т. е., по сути, process.nextTick может сработать 
абсолютно на любой фазе. Какого-то готового инструмента, 
чтобы запустить код на фазе «ожидание, подготовка», в Node.js нет.

В исходном коде это строки 368, 369:
**uv_run_idle(loop)** — ожидание;
**uv_run_prepare(loop)** — подготовка.

### 4 фаза — опрос

Здесь выполняется весь наш код, который мы пишем на JS. 
Первоначально все запросы, которые мы делаем, попадают 
именно сюда, и именно здесь Node.js может быть заблокирована. 
Если сюда попадёт какая-либо тяжёлая операция по вычислению, 
то на этом этапе наше приложение может просто зависнуть и ожидать, 
пока не выполнится данная операция.

В исходном коде это строка 370: **uv_io_poll(loop, timeout)**.

### 5 фаза — проверка

В Node.js есть таймер setImmediate, его callback'и 
выполняются на этой фазе.

В исходном коде это строка 371: **uv_run_check(loop)**.

### 6 фаза (последняя) — callback'и событий close

Например, web-сокету нужно закрыть соединение, на этой фазе 
будет вызван callback этого события.

В исходном коде это строка 372: **uv_run_closing_handless(loop)**.