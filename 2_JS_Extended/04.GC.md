# 3. Сборка мусора

Управление памятью в JavaScript выполняется автоматически и незаметно. 
Мы создаём примитивы, объекты, функции… Всё это занимает память.
Как JavaScript понимает, что пора очищать память?
                                                                 
### Достижимость
Основной концепцией управления памятью в JavaScript является принцип достижимости.

Если упростить, то «достижимые» значения – это те, которые доступны или используются. 
Они гарантированно находятся в памяти.

- Существует базовое множество достижимых значений, которые не могут быть удалены:
    - Глобальные переменные.
    - Локальные переменные и параметры текущей функции (контекста).
    - Переменные и параметры других функций в текущей цепочке вложенных вызовов. (замыкания)

Будем называть эти значения **корнями**.

- Любое другое значение считается достижимым, если оно доступно из корня 
по ссылке или по цепочке ссылок.

Например, если в локальной переменной есть объект, и он имеет свойство, в котором хранится ссылка на другой объект, 
то этот объект считается достижимым. И те, на которые он ссылается, тоже достижимы.

В интерпретаторе JavaScript есть фоновый процесс, который называется сборщик мусора. Он следит за всеми объектами и 
удаляет те, которые стали недостижимы.

```
let user = {
  name: "John"
};
```
![GC_1](https://github.com/llevkin/katacoda-scenarios/blob/master/2_JS_Extended/img/GC_1.png?raw=true)

Здесь стрелка обозначает ссылку на объект. Глобальная переменная user ссылается на объект {name: "John"} (мы будем называть его просто «John»). В свойстве "name" объекта John хранится примитив, поэтому оно нарисовано внутри объекта.

Если перезаписать значение user, то ссылка потеряется:

```
user = null;
```
![GC_2](https://github.com/llevkin/katacoda-scenarios/blob/master/2_JS_Extended/img/GC_2.png?raw=true)

Теперь объект John становится недостижимым. К нему нет доступа, на него нет ссылок. 
Сборщик мусора удалит эти данные и освободит память.

### Две ссылки

Представим, что мы скопировали ссылку из user в admin:
```
// в user находится ссылка на объект
let user = {
  name: "John"
};

let admin = user;
```

![GC_3](https://github.com/llevkin/katacoda-scenarios/blob/master/2_JS_Extended/img/GC_3.png?raw=true)

Теперь, если мы сделаем то же самое:

```
user = null;
```

Объект John всё ещё достижим через глобальную переменную admin, поэтому он находится 
в памяти. Если бы мы также перезаписали admin, то John был бы удалён.