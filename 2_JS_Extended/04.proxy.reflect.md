# 4. Proxy и Reflect

### 4.1 Proxy
Объект Proxy «оборачивается» вокруг другого объекта и может перехватывать 
(и, при желании, самостоятельно обрабатывать) разные действия с ним, 
например чтение/запись свойств и другие.

```
let proxy = new Proxy(target, handler)
```
- target – это объект, для которого нужно сделать прокси, может быть любым объектом, включая функции.
- handler – конфигурация прокси: объект с «ловушками» («traps»): методами, которые перехватывают разные операции.

Ограничения прокси
Прокси – уникальное средство для настройки поведения объектов на самом низком уровне. 
Но они не идеальны, есть некоторые ограничения.

Встроенные объекты: внутренние слоты
Многие встроенные объекты, например Map, Set, Date, Promise и другие используют 
так называемые «внутренние слоты».

Это как свойства, но только для внутреннего использования в самой спецификациии. 
Например, Map хранит элементы во внутреннем слоте [[MapData]]. Встроенные методы 
обращаются к слотам напрямую, не через [[Get]]/[[Set]]. Таким образом, прокси не 
может перехватить их. Если встроенный объект проксируется, то в прокси не будет этих 
«внутренних слотов», так что попытка вызвать на таком прокси встроенный метод приведёт 
к ошибке.

| JavaScript код                                | Метод обработчика                                    | Описание |
|-----------------------------------------------|:----------------------------------------------------:|:--------:|
| proxy.name  | get function(target, name, receiver): any |  |
| proxy.name = val  | set function(target, name, val, receiver): boolean |  |
| delete proxy.name  | deleteProperty function(target, name): boolean | Удаляет именованное свойство из прокси. Возвращает true в случае успешного удаления свойства name. |
| name in proxy  | has function(target, name): boolean |  |
| proxy(...args), proxy.apply(thisValue, args), proxy.call(thisValue, ...args)  | apply function(target, thisValue, args): any | target должен быть функцией. |
| new proxy(...args)  | construct function(target, args): object | target должен быть функцией. |
| Object.preventExtensions(proxy)  | preventExtensions function(target): boolean | Делает объект нерасширяемым. Возвращает true при успешном выполнении. |
| Object.getOwnPropertyDescriptor(proxy, name)  | getOwnPropertyDescriptor(target, name): undefined    | Должен возвращать верный объект-описание свойства или undefined, чтобы показать, что свойство с именем name существует в эмулируемом объекте. |
| Object.getOwnPropertyNames(proxy), Object.getOwnPropertySymbols(proxy), Object.keys(proxy)  | ownKeys(target): (string, symbol)    | Возвращает массив всех собственных (не унаследованных) имён свойств эмулируемого объекта. |
| Object.defineProperty(proxy, name, pd)  | defineProperty function(target, name, propertyDescriptor): any | Задаёт новое свойство, атрибуты которого определяются предоставленным propertyDescriptor. Возвращаемое значение метода игнорируется. |

### 4.2 Reflect
Reflection/Reflect API  —  это API, который предоставляет возможность проводить 
реверс-инжиниринг классов, интерфейсов, функций, методов и модулей.
Reflection API существует в разных языках программирования и, порой, используется 
для обхода ограничений, накладываемых ЯП.

Reflect  —  это встроенный объект, который предоставляет методы для перехватывания 
JavaScript операций. Reflect содержит в себе набор функций, которые называются точно 
так же, как и методы для Proxy.

Некоторые из этих методов  —  те же, что и соответствующие им методы класса Object 
или Function. JavaScript растет и превращается в большой и сложный ЯП. 
В язык приходят различные вещи из других языков. На сегодня Reflect API умеет не 
так много, как в других ЯП. Тем не менее, есть предложения по расширению.