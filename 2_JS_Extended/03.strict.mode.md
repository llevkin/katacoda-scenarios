# 3. Строгий режим

Строгий режим влияет и на синтаксис кода, и на то, как код 
ведёт себя во время выполнения программы. Ошибки в коде 
преобразуются в исключения. То, что в нестрогом режиме тихо даёт сбой, 
в строгом вызывает сообщение об ошибке. Это похоже на то, как в 
нестрогом режиме система реагирует на синтаксические ошибки. 
В строгом режиме упрощается работа с переменными, жёстко регулируется 
использование функции eval и объекта arguments, упорядочивается работа с 
конструкциями, которые могут быть реализованы в будущих версиях языка.

«Тихие» ошибки преобразуются в строгом режиме в исключения. 
В нестрогом режиме на такие ошибки система явным образом не реагирует. 
В строгом же режиме наличие таких ошибок приводит к неработоспособности кода.

Что ьы включить строгий режим надо поместить конструкцию "use strict" или 'use strict' 
в верхнюю часть тела функции (или в глобальный контекст). Строгий режим при таком 
подходе применяется ко всему, что размещено в теле функции, включая вложенные функции.

##### Некоторые методы объектов которые нам понадобятся для понимания этой главы:

**Object.seal(obj)** - запечатывает объект, предотвращая добавление новых свойств к объекту и делая все существующие свойства не настраиваемыми.

**Object.freeze(obj)** - замораживает объект: это значит, что он предотвращает добавление новых свойств к объекту, удаление старых свойств из объекта и изменение существующих свойств или значения их атрибутов перечисляемости, настраиваемости и записываемости. В сущности, объект становится эффективно неизменным.

**Object.preventExtensions(obj)** - предотвращает добавление новых свойств к объекту (то есть, предотвращает расширение этого объекта в будущем).

**Object.defineProperty(obj, prop, descriptor)** - определяет новое или изменяет существующее свойство непосредственно на объекте.

### 3.1 Отличия

- Cоздание переменных без директив let, var, const приведёт к исключению.
```
    'use strict';

    badVariable = 1;
```

- В строгом режиме нельзя выполнять операции присваивания значений таким сущностям,
предназначенным только для чтения, как arguments, NaN или eval и т.д.
```
    'use strict';

    let undefined = 5; 
    let Infinity = 5;
    let NaN = 5;
```

- Попытка записи значения в свойство, у которого есть лишь геттер выбросит исключение.
```
    'use strict';

    let obj2 = { get foo() { return 17; } };
    obj2.foo = 2;
```

- Попытка записи чего-либо в свойство нерасширяемого объекта.
```
    'use strict';

    let fixedObj = {};
    Object.preventExtensions(fixedObj);
    fixed.bar = 1;
```

- Строгий режим запрещает назначать объекту свойства с одинаковыми именами.
```
    'use strict';

    let o = { a: 1, a: 2 };
```

- Строгий режим требует, чтобы имена параметров функций были бы уникальными.
```
    'use strict';

    const multiply = (x, x, y) => x*x*y;
```

- Строгий режим, кроме того, запрещает использование конструкций, 
затрудняющих оптимизацию. `with` - запрещён.
```
    'use strict';

    let x = 1;
    with (obj) {
      x;
    }
```

- Строгий режим, кроме того, запрещает удаление обычных переменных. 
```
    'use strict';

    let x;
    delete x;
```

- В строгом режиме запрещено неправильное использование eval и arguments. 
Речь идёт о запрете всяческих манипуляций с ними. 
Например — это нечто вроде присваивания им новых значений, 
использование их имён в роли имён переменных, функций, параметров функций.
```
    'use strict';

    eval = 1;
    arguments++;
    arguments--;
    ++eval;
    eval--;
    let obj = { set p(arguments) { } };
    let eval;
    try { } catch (arguments) { }
    try { } catch (eval) { }
    function x(eval) { }
    function arguments() { }
    let y = function eval() { };
    let eval = ()=>{ };
    let f = new Function('arguments', "'use strict'; return 1;");
```

- В строгом режиме нельзя создавать псевдонимы для объекта arguments и 
устанавливать новые значения arguments через эти псевдонимы.
```
    const fn = function(a) {
      'use strict';
      a = 2;
      return [a, arguments[0]];
    }
    console.log(fn(1));
```

- Не поддерживается свойство arguments.callee, 
Function.caller, Function.arguments.
```
'use strict';

function test() {
}

console.log(test.caller);
```

```
'use strict';

function test() {
}

console.log(test.arguments);
```

```
'use strict';

function test() {
    console.log(arguments.callee);
}

test();
```

- В строгом режиме ключевое слово this не обязано всегда быть объектом. 
```
'use strict';

function fn() {
  return this;
}
console.log(fn() === undefined);
console.log(fn.call(2) === 2);
console.log(fn.call('test') === 'test');
console.log(fn.apply(null) === null);
console.log(fn.call(undefined) === undefined);
console.log(fn.bind(true)() === true);
```

- В строгом режиме для именования переменных или свойств объектов нельзя использовать идентификаторы, 
которые могут найти применение в будущих версиях JavaScript. Речь идёт, например, о следующих идентификаторах: 
implements, interface, let, package, private, protected, public, static и yield, и т.д.