# 5. Сборка мусора

Оригинальная статья тут: 
https://learn.javascript.ru/garbage-collection#vzaimosvyazannye-obekty

Управление памятью в JavaScript выполняется автоматически и незаметно. 
Мы создаём примитивы, объекты, функции… Всё это занимает память.
Как JavaScript понимает, что пора очищать память?
                                                                 
### 5.1 Достижимость
Основной концепцией управления памятью в JavaScript является принцип достижимости.

Если упростить, то «достижимые» значения – это те, которые доступны или используются. 
Они гарантированно находятся в памяти.

- Существует базовое множество достижимых значений, которые не могут быть удалены:
    - Глобальные переменные.
    - Локальные переменные и параметры текущей функции.
    - Переменные и параметры других функций в текущей цепочке вложенных вызовов.

Будем называть эти значения **корнями**.

- Любое другое значение считается достижимым, если оно доступно из корня 
по ссылке или по цепочке ссылок.

Например, если в локальной переменной есть объект, и он имеет свойство, в котором хранится ссылка на другой объект, 
то этот объект считается достижимым. И те, на которые он ссылается, тоже достижимы.

В интерпретаторе JavaScript есть фоновый процесс, который называется сборщик мусора. Он следит за всеми объектами и 
удаляет те, которые стали недостижимы.

```
let user = {
  name: "John"
};
```
![GC_1](https://github.com/llevkin/katacoda-scenarios/blob/master/2_JS_Extended/img/GC_1.png?raw=true)

Здесь стрелка обозначает ссылку на объект. Глобальная переменная user ссылается на объект {name: "John"} (мы будем называть его просто «John»). В свойстве "name" объекта John хранится примитив, поэтому оно нарисовано внутри объекта.

Если перезаписать значение user, то ссылка потеряется:

```
user = null;
```
![GC_2](https://github.com/llevkin/katacoda-scenarios/blob/master/2_JS_Extended/img/GC_2.png?raw=true)

Теперь объект John становится недостижимым. К нему нет доступа, на него нет ссылок. 
Сборщик мусора удалит эти данные и освободит память.

### 5.2 Две ссылки

Представим, что мы скопировали ссылку из user в admin:
```
// в user находится ссылка на объект
let user = {
  name: "John"
};

let admin = user;
```

![GC_3](https://github.com/llevkin/katacoda-scenarios/blob/master/2_JS_Extended/img/GC_3.png?raw=true)

Теперь, если мы сделаем то же самое:

```
user = null;
```

Объект John всё ещё достижим через глобальную переменную admin, поэтому он находится 
в памяти. Если бы мы также перезаписали admin, то John был бы удалён.

### 5.3 Взаимосвязанные объекты

Теперь более сложный пример. Семья:

```
let family = {
    father: {
        name: "John",
    },
    mother: {
        name: "Ann",
    },
};

family.father.wife = family.mother;
family.mother.husband = family.father;
```

У двух объектов, есть ссылки друг на друга.

В результате получаем такую структуру памяти:

![GC_4](https://github.com/llevkin/katacoda-scenarios/blob/master/2_JS_Extended/img/GC_4.png?raw=true)

На данный момент все объекты достижимы.

Теперь удалим две ссылки:

```
delete family.father;
delete family.mother.husband;
```

![GC_5](https://github.com/llevkin/katacoda-scenarios/blob/master/2_JS_Extended/img/GC_5.png?raw=true)

Недостаточно удалить только одну из этих ссылок, потому что все объекты 
останутся достижимыми.

Но если мы удалим обе, то увидим, что у объекта John больше нет входящих ссылок:

![GC_6](https://github.com/llevkin/katacoda-scenarios/blob/master/2_JS_Extended/img/GC_6.png?raw=true)

Исходящие ссылки не имеют значения. Только входящие ссылки могут сделать объект 
достижимым. Объект John теперь недостижим и будет удалён из памяти со всеми 
своими данными, которые также стали недоступны.

После сборки мусора:

![GC_7](https://github.com/llevkin/katacoda-scenarios/blob/master/2_JS_Extended/img/GC_7.png?raw=true)

### 5.4 Недостижимый «остров»

Вполне возможна ситуация, при которой целый «остров» связанных объектов 
может стать недостижимым и удалиться из памяти.

Возьмём объект family из примера выше. А затем:

```
family = null;
```

Структура в памяти теперь станет такой:

![GC_8](https://github.com/llevkin/katacoda-scenarios/blob/master/2_JS_Extended/img/GC_8.png?raw=true)

Этот пример демонстрирует, насколько важна концепция достижимости.

Объекты John и Ann всё ещё связаны, оба имеют входящие ссылки, но этого недостаточно.

У объекта family больше нет ссылки от корня, поэтому весь «остров» 
становится недостижимым и будет удалён.

### 5.5 Внутренние алгоритмы

Основной алгоритм сборки мусора – «алгоритм пометок» (англ. «mark-and-sweep»).

Согласно этому алгоритму, сборщик мусора регулярно выполняет следующие шаги:

- Сборщик мусора «помечает» (запоминает) все корневые объекты.
- Затем он идёт по их ссылкам и помечает все найденные объекты.
- Затем он идёт по ссылкам помеченных объектов и помечает объекты, на которые есть ссылка от них.
- …И так далее, пока не будут посещены все ссылки (достижимые от корней).
- Все непомеченные объекты удаляются.

Например, пусть наша структура объектов выглядит так:

![GC_9](https://github.com/llevkin/katacoda-scenarios/blob/master/2_JS_Extended/img/GC_9.png?raw=true)

Явно виден «недостижимый остров» справа. Теперь посмотрим, как будет работать «алгоритм пометок» сборщика мусора.

На первом шаге помечаются корни:

![GC_10](https://github.com/llevkin/katacoda-scenarios/blob/master/2_JS_Extended/img/GC_10.png?raw=true)

Затем помечаются объекты по их ссылкам:

![GC_11](https://github.com/llevkin/katacoda-scenarios/blob/master/2_JS_Extended/img/GC_11.png?raw=true)

…а затем объекты по их ссылкам и так далее, пока это вообще возможно:

![GC_12](https://github.com/llevkin/katacoda-scenarios/blob/master/2_JS_Extended/img/GC_12.png?raw=true)

Теперь объекты, до которых не удалось дойти от корней, 
считаются недостижимыми и будут удалены:

![GC_13](https://github.com/llevkin/katacoda-scenarios/blob/master/2_JS_Extended/img/GC_13.png?raw=true)

Это и есть принцип работы сборки мусора.

Интерпретаторы JavaScript применяют множество оптимизаций, чтобы сборка мусора работала быстрее и не влияла на производительность.

Вот некоторые из оптимизаций:

- **Сборка по поколениям** (Generational collection) – объекты делятся на «новые» и «старые». Многие объекты появляются, выполняют свою задачу и быстро умирают, их можно удалять более агрессивно. Те, которые живут достаточно долго, становятся «старыми» и проверяются реже.
- **Инкрементальная сборка** (Incremental collection) – если объектов много, то обход всех ссылок и пометка достижимых объектов может занять значительное время и привести к видимым задержкам выполнения скрипта. Поэтому интерпретатор пытается организовать сборку мусора поэтапно. Этапы выполняются по отдельности один за другим. Это требует дополнительного учёта для отслеживания изменений между этапами, но зато теперь у нас есть много крошечных задержек вместо одной большой.
- **Сборка в свободное время** (Idle-time collection) – чтобы уменьшить возможное влияние на производительность, сборщик мусора старается работать только во время простоя процессора.

### Итого:

- Сборка мусора выполняется автоматически. Мы не можем ускорить или предотвратить её.
(на самом деле это не совсем так)
- Объекты сохраняются в памяти, пока они достижимы.
- Наличие ссылки не гарантирует, что объект достижим (от корня): несколько 
взаимосвязанных объектов могут стать недостижимыми как единое целое.